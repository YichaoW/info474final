{"ast":null,"code":"var _jsxFileName = \"/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/RuleOfThumb.js\";\nimport React, { Component } from 'react';\nexport class RuleOfThumb extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 18\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 19\n      },\n      __self: this\n    }, \"Rule of Thumb\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 20\n      },\n      __self: this\n    }, \"In real life, not all cases are general cases. Somtimes those analysis may not work under some special cases. One example can be, suppose the lists in your application are almost sorted, meaning there is a fix number of items that are not sorted. In this case, since the number of insertion is fixed and not dependent on the length of the array, insertion sort actually performs better since its runtime is just O(n) is the number of insertion is fixed. With those in mind, if you just want to have the algorithm with the best trade-off, considering the properties of your lists in the app can sometimes give you good advices.\"));\n  }\n\n}","map":{"version":3,"sources":["/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/RuleOfThumb.js"],"names":["React","Component","RuleOfThumb","constructor","props","state","componentDidMount","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AAEA,OAAO,MAAMC,WAAN,SAA0BD,SAA1B,CAAoC;AACvCE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA,SAAKC,KAAL,GAAa,EAAb;AAGH;;AAEDC,EAAAA,iBAAiB,GAAG,CAEnB;;AAEDC,EAAAA,MAAM,GAAG;AACL,WACI;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBADJ,EAEI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4nBAFJ,CADJ;AAcH;;AA5BsC","sourcesContent":["import React, { Component } from 'react';\n\nexport class RuleOfThumb extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <div className=\"intro-container\">\n                <h1>Rule of Thumb</h1>\n                <p className='intro-text'>\n                    In real life, not all cases are general cases. Somtimes those analysis may not work under some special cases. One example can be,\n                     suppose the lists in your application are almost sorted, meaning there is a fix number of items that are not sorted. In this case, \n                      since the number of insertion is fixed and not dependent on the length of the array, insertion sort actually performs better since its runtime \n                      is just O(n) is the number of insertion is fixed. With those in mind, if you just want to have the algorithm with the best trade-off, considering \n                      the properties of your lists in the app can sometimes give you good advices.\n\n\n                </p>\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}