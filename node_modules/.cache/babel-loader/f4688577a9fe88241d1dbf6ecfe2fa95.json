{"ast":null,"code":"var _jsxFileName = \"/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/ComplexityAnalysis.js\";\nimport React, { Component } from 'react';\nimport { Nav, Image, Table } from 'react-bootstrap';\nimport timePlot from './image/timeplot.png';\nimport spacePlot from './image/spaceplot.png';\nimport MathJax from 'react-mathjax2';\nexport class ComplexityAnalysis extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      displayTimePlot: true\n    };\n    this.handleChangePlot = this.handleChangePlot.bind(this);\n  }\n\n  handleChangePlot() {\n    this.setState({\n      displayTimePlot: !this.state.displayTimePlot\n    });\n  }\n\n  componentDidMount() {}\n\n  render() {\n    let plotImage;\n\n    if (this.state.displayTimePlot) {\n      plotImage = React.createElement(Image, {\n        src: timePlot,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 28\n        },\n        __self: this\n      });\n    } else {\n      plotImage = React.createElement(Image, {\n        src: spacePlot,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 30\n        },\n        __self: this\n      });\n    }\n\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 36\n      },\n      __self: this\n    }, \"Complexity Analysis\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38\n      },\n      __self: this\n    }, \"There are many sorting algorithms in programming world. However, there exist tradeoffs among the algorithms. In order to compare the performance of different algorithms, we should consider time complexity and space complexity. Time complexity denotes the amount of time taken by an algorithm to run based on the length of the input. Similarly, space complexity denotes the amount of space or memory taken by an algorithm to run based on the length of the input.\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 42\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 43\n      },\n      __self: this\n    }, \"Normally, we use Big O-notation to analyze algorithms. This concept determines which is the dominant term of a function. In order words, it asks which term in the function grow the fastest. For example, if a function \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45\n      },\n      __self: this\n    }, 'f(n)=0.001n^2+2n+100'), \", even the coefficent of \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45\n      },\n      __self: this\n    }, 'n^2'), \" is smalle, it still grows the fastest when n goes to infinity, which means \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46\n      },\n      __self: this\n    }, 'O(f(n))=n^2'), \"If you are interested in the rigorious definition, here it is:\", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50\n      },\n      __self: this\n    }, 'f(n)=O(g(n))'), \" if there exists a positive integer \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 51\n      },\n      __self: this\n    }, 'n_0'), \" and a positive constant \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 51\n      },\n      __self: this\n    }, 'c', \" \"), \" such that \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 51\n      },\n      __self: this\n    }, 'f(n)\\\\leq cg(n) \\\\forall n \\\\geq n_0'), \".\")), React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 55\n      },\n      __self: this\n    }, React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 56\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 57\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }, 'f(n)=O(g(n))'), \" if there exists a positive integer \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }, 'n_0'), \" and a positive constant \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }, 'c', \" \"), \" such that \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }, 'f(n)\\\\leq cg(n) \\\\forall n \\\\geq n_0'), \".\"))), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63\n      },\n      __self: this\n    }, \"Selection Sort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 65\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66\n      },\n      __self: this\n    }, \"For each time to pick the minimum of the unsorted list, it is most likely to go through all of the items in the unsorted list. If you calculate arithemetic sum, the dominant term is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67\n      },\n      __self: this\n    }, 'n^2'), \", which means, in general, the runtime complexity for selection sort is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 68\n      },\n      __self: this\n    }, 'O(n^2)'), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 69\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 70\n      },\n      __self: this\n    }), \"And as for space complexity, the sorting can be done within the given array so that it does not require extra memory (see the animation). Thus, the space complexity is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71\n      },\n      __self: this\n    }, 'O(1)'), \".\")), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75\n      },\n      __self: this\n    }, \"Insertion Sort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 78\n      },\n      __self: this\n    }, \"Similar to selection sort, for each iteration of the insertion, an item is likely to search for the entire sorted list. This means the sum of the operation is similar wi th the sum in selection sort, which makes it has the time complexity \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 80\n      },\n      __self: this\n    }, 'O(n^2)'), \".\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 81\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 82\n      },\n      __self: this\n    }), \"Similarily, as demonstrated by the animation, insertion sort does not need extra space, which means it has space complexity is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 83\n      },\n      __self: this\n    }, 'O(1)'), \".\")), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87\n      },\n      __self: this\n    }, \"Merge Sort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89\n      },\n      __self: this\n    }, React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 90\n      },\n      __self: this\n    }, \"The time complexity of the merge sort is quite hard to analyze since it involves recursion. However, if you want to do the quick estimation, there are some tr icks: for an array whose length is n, merge sort need to take \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 92\n      },\n      __self: this\n    }, 'log_2(n)'), \" levels, and for \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 92\n      },\n      __self: this\n    }, 'i^{th}'), \" level, the length of array for processing is \", React.createElement(MathJax.Node, {\n      inline: true,\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 93\n      },\n      __self: this\n    }, '\\\\frac{n}{2^i}'), \". Since merging two arrays need to iterate both arrays, if you take the sum, the dominant term for merge sort is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 94\n      },\n      __self: this\n    }, 'O(nlogn)'), \".\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 95\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 96\n      },\n      __self: this\n    }), \"Since there are \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98\n      },\n      __self: this\n    }, 'log_2(n)'), \" levels and each level needs to store the entire array, its space complexity become the product, which is \", React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98\n      },\n      __self: this\n    }, 'O(nlog(n))'))), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 103\n      },\n      __self: this\n    }, \"Time and Space Complexity Comparison Table \"), React.createElement(Table, {\n      responsive: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 105\n      },\n      __self: this\n    }, React.createElement(\"thead\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 106\n      },\n      __self: this\n    }, React.createElement(\"tr\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 107\n      },\n      __self: this\n    }, React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 108\n      },\n      __self: this\n    }, \"Sorting Algorithm\"), React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 109\n      },\n      __self: this\n    }, \"General Time Complexity\"), React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 110\n      },\n      __self: this\n    }, \"General Space Complexity\"))), React.createElement(\"tbody\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 113\n      },\n      __self: this\n    }, React.createElement(\"tr\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 116\n      },\n      __self: this\n    }, \"Selection Sort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 117\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 118\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 118\n      },\n      __self: this\n    }, 'O(n^2)'))), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 121\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 122\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 122\n      },\n      __self: this\n    }, 'O(1)')))), React.createElement(\"tr\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 126\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 127\n      },\n      __self: this\n    }, \"Insertion Sort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 128\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129\n      },\n      __self: this\n    }, 'O(n^2)'))), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 132\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 133\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 133\n      },\n      __self: this\n    }, 'O(1)')))), React.createElement(\"tr\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 137\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 138\n      },\n      __self: this\n    }, \"MergeSort\"), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 140\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 140\n      },\n      __self: this\n    }, 'O(nlogn)'))), React.createElement(MathJax.Context, {\n      input: \"tex\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 143\n      },\n      __self: this\n    }, React.createElement(\"td\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144\n      },\n      __self: this\n    }, React.createElement(MathJax.Node, {\n      inline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144\n      },\n      __self: this\n    }, 'O(nlog(n))')))))), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149\n      },\n      __self: this\n    }, \"Time and Space Complexity Plots\"), React.createElement(Nav, {\n      variant: \"tabs\",\n      defaultActiveKey: \"time\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 150\n      },\n      __self: this\n    }, React.createElement(Nav.Item, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 151\n      },\n      __self: this\n    }, React.createElement(Nav.Link, {\n      eventKey: \"time\",\n      onClick: this.handleChangePlot,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152\n      },\n      __self: this\n    }, \"Time\")), React.createElement(Nav.Item, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 154\n      },\n      __self: this\n    }, React.createElement(Nav.Link, {\n      eventKey: \"space\",\n      onClick: this.handleChangePlot,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 155\n      },\n      __self: this\n    }, \"Space\"))), plotImage, React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160\n      },\n      __self: this\n    }, \"From above, we can see although the time complexity for merge sort is O(nlogn) which is faster than insertion and selection sort, it takes more space to run.\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 164\n      },\n      __self: this\n    }, \"In addition to time and space complexity, sometimes we also care stability of the sorting algorithms. A sorting technique is stable if it does not change the order of elements with the same value. Insertion sort and merge sort are stable while selection sort is not.\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168\n      },\n      __self: this\n    }, \"Therefore, we can choose the best algorithm to solve particular problem by evaluate these tradeoffs.\"));\n  }\n\n}","map":{"version":3,"sources":["/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/ComplexityAnalysis.js"],"names":["React","Component","Nav","Image","Table","timePlot","spacePlot","MathJax","ComplexityAnalysis","constructor","props","state","displayTimePlot","handleChangePlot","bind","setState","componentDidMount","render","plotImage"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Nav, Image, Table} from 'react-bootstrap';\nimport timePlot from './image/timeplot.png';\nimport spacePlot from './image/spaceplot.png';\nimport MathJax from 'react-mathjax2'\n\nexport class ComplexityAnalysis extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n            displayTimePlot: true\n        }\n        this.handleChangePlot = this.handleChangePlot.bind(this)\n    }\n   \n    handleChangePlot() {\n        this.setState({displayTimePlot: !this.state.displayTimePlot})\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        let plotImage;\n        if (this.state.displayTimePlot) {\n            plotImage = <Image src={timePlot}></Image>\n        } else {\n            plotImage = <Image src={spacePlot}></Image>\n        }\n\n\n        return(\n            <div className=\"intro-container\">\n                <h1>Complexity Analysis</h1>\n                \n                <p className='intro-text'>\n                There are many sorting algorithms in programming world. However, there exist tradeoffs among the algorithms. In order to compare the performance of different algorithms, we should consider time complexity and space complexity. Time complexity denotes the amount of time taken by an algorithm to run based on the length of the input. Similarly, space complexity denotes the amount of space or memory taken by an algorithm to run based on the length of the input.\n\n                </p>\n                <MathJax.Context input='tex'>\n                    <p className='intro-text'>\n                        Normally, we use Big O-notation to analyze algorithms. This concept determines which is the dominant term of a function. In order words, it asks which term in the function grow the fastest.\n                        For example, if a function <MathJax.Node inline>{'f(n)=0.001n^2+2n+100'}</MathJax.Node>, even the coefficent of <MathJax.Node inline>{'n^2'}</MathJax.Node> is smalle, it still grows the\n                        fastest when n goes to infinity, which means <MathJax.Node inline>{'O(f(n))=n^2'}</MathJax.Node>\n                        \n                        If you are interested in the rigorious definition, here it is:\n\n                        <MathJax.Node inline>{'f(n)=O(g(n))'}</MathJax.Node> if there exists \n                        a positive integer <MathJax.Node inline>{'n_0'}</MathJax.Node> and a positive constant <MathJax.Node inline>{'c'} </MathJax.Node> such that <MathJax.Node inline>{'f(n)\\\\leq cg(n) \\\\forall n \\\\geq n_0'}</MathJax.Node>.\n                    </p>\n                </MathJax.Context>\n\n                <div>\n                    <MathJax.Context input='tex'>\n                        <p>\n                            <MathJax.Node inline>{'f(n)=O(g(n))'}</MathJax.Node> if there exists a positive integer <MathJax.Node inline>{'n_0'}</MathJax.Node> and a positive constant <MathJax.Node inline>{'c'} </MathJax.Node> such that <MathJax.Node inline>{'f(n)\\\\leq cg(n) \\\\forall n \\\\geq n_0'}</MathJax.Node>.\n                        </p>\n                    </MathJax.Context>\n                </div>\n\n                <h2>Selection Sort</h2>\n\n                <MathJax.Context input='tex'>\n                <p className='intro-text'>\n                    For each time to pick the minimum of the unsorted list, it is most likely to go through all of the items in the unsorted list. If you calculate arithemetic sum, the dominant term is <MathJax.Node inline>{'n^2'}</MathJax.Node>,\n                    which means, in general, the runtime complexity for selection sort is <MathJax.Node inline>{'O(n^2)'}</MathJax.Node> \n                    <br></br>\n                    <br></br>\n                    And as for space complexity, the sorting can be done within the given array so that it does not require extra memory (see the animation). Thus, the space complexity is <MathJax.Node inline>{'O(1)'}</MathJax.Node>.\n                </p>\n                </MathJax.Context>\n\n                <h2>Insertion Sort</h2>\n\n                <MathJax.Context input='tex'>\n                <p className='intro-text'>\n                    Similar to selection sort, for each iteration of the insertion, an item is likely to search for the entire sorted list. This means the sum of the operation is similar wi\n                    th the sum in selection sort, which makes it has the time complexity <MathJax.Node inline>{'O(n^2)'}</MathJax.Node>.\n                    <br></br>\n                    <br></br>\n                    Similarily, as demonstrated by the animation, insertion sort does not need extra space, which means it has space complexity is <MathJax.Node inline>{'O(1)'}</MathJax.Node>.\n                </p>\n                </MathJax.Context>\n\n                <h2>Merge Sort</h2>\n\n                <MathJax.Context input='tex'>\n                <p className='intro-text'>\n                    The time complexity of the merge sort is quite hard to analyze since it involves recursion. However, if you want to do the quick estimation, there are some tr\n                    icks: for an array whose length is n, merge sort need to take <MathJax.Node inline>{'log_2(n)'}</MathJax.Node> levels, and for <MathJax.Node inline>{'i^{th}'}</MathJax.Node> level, \n                    the length of array for processing is <MathJax.Node inline input = 'tex'>{'\\\\frac{n}{2^i}'}</MathJax.Node>. Since merging two arrays need to iterate both arrays, if you take the sum,\n                    the dominant term for merge sort is <MathJax.Node inline>{'O(nlogn)'}</MathJax.Node>.\n                    <br></br>\n                    <br></br>\n                    \n                    Since there are <MathJax.Node inline>{'log_2(n)'}</MathJax.Node> levels and each level needs to store the entire array, its space complexity become the product, which is <MathJax.Node inline>{'O(nlog(n))'}</MathJax.Node>\n                </p>\n                </MathJax.Context>\n\n\n                <h2>Time and Space Complexity Comparison Table </h2>\n\n                <Table responsive>\n                    <thead>\n                        <tr>\n                        <th>Sorting Algorithm</th>\n                        <th>General Time Complexity</th>\n                        <th>General Space Complexity</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        \n                        <tr>\n                        <td>Selection Sort</td>\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(n^2)'}</MathJax.Node></td>\n                        </MathJax.Context>\n\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(1)'}</MathJax.Node></td>\n                        </MathJax.Context>\n                        </tr>\n\n                        <tr>\n                        <td>Insertion Sort</td>\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(n^2)'}</MathJax.Node></td>\n                        </MathJax.Context>\n\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(1)'}</MathJax.Node></td>\n                        </MathJax.Context>\n                        </tr>\n                        \n                        <tr>\n                        <td>MergeSort</td>\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(nlogn)'}</MathJax.Node></td>\n                        </MathJax.Context>\n\n                        <MathJax.Context input='tex'>\n                        <td><MathJax.Node inline>{'O(nlog(n))'}</MathJax.Node></td>\n                        </MathJax.Context>\n                        </tr>\n                    </tbody>\n                </Table>\n                <h2>Time and Space Complexity Plots</h2>\n                <Nav variant=\"tabs\" defaultActiveKey=\"time\">\n                <Nav.Item>\n                    <Nav.Link eventKey=\"time\" onClick={this.handleChangePlot}>Time</Nav.Link>\n                </Nav.Item>\n                <Nav.Item>\n                    <Nav.Link eventKey=\"space\" onClick={this.handleChangePlot}>Space</Nav.Link>\n                </Nav.Item>\n                </Nav>\n                {plotImage}\n\n                <p className='intro-text'>\n                From above, we can see although the time complexity for merge sort is O(nlogn) which is faster than insertion and selection sort, it takes more space to run. \n                </p>\n\n                <p className='intro-text'>\n                In addition to time and space complexity, sometimes we also care stability of the sorting algorithms. A sorting technique is stable if it does not change the order of elements with the same value. Insertion sort and merge sort are stable while selection sort is not.\n                </p>\n\n                <p className='intro-text'>\n                Therefore, we can choose the best algorithm to solve particular problem by evaluate these tradeoffs.  \n                </p>\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}