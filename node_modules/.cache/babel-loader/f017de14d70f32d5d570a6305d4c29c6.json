{"ast":null,"code":"var _jsxFileName = \"/Users/wyc/Desktop/info474final/src/Components/SortingAlgorithms.js\";\nimport React, { Component } from 'react';\nimport { SelectionSort } from './SelectionSort';\nimport { Insertion } from './Insertion';\nimport { MergeSortBasic } from './MergeSortBasic';\nimport { MergeSort } from './MergeSort';\nexport class SortingAlgorithms extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 22\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 23\n      },\n      __self: this\n    }, \"Sorting Algorithms\"), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 24\n      },\n      __self: this\n    }, \"Selection Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 25\n      },\n      __self: this\n    }), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 27\n      },\n      __self: this\n    }), React.createElement(SelectionSort, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 30\n      },\n      __self: this\n    }), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 33\n      },\n      __self: this\n    }, \"Insertion Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 34\n      },\n      __self: this\n    }, \"Insertion sort using facts that are even more obvious than the fact for selection sort. For this sorting algorithm works, there are two major requirements: \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA01. An array with only one or zero element is considered as a sorted array. \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 36\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA02. A sorted array is still sorted when a new item is inserted at the position where its value is between its neighbors. \", \"(Such as 1st Neighbor < Inserted Value <2nd Neighbor)\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 40\n      },\n      __self: this\n    }, \"With those two facts, we can have an iteration that, we pick the first item of the unsorted array, and then the value is inserted into the appropriate place. And once there is no more item to be picked, we can get a sorted array. And the following pseudocode shows the basic logic to instruct computers to process insertion:\"), React.createElement(\"code\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 44\n      },\n      __self: this\n    }, \"i \\u2190 1 \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45\n      },\n      __self: this\n    }), 'while i < length(A)', \" \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0     j \\u2190 i \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 47\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0      while j > 0 and A[j-1] > A[j]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 48\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0          swap A[j] and A[j-1]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 49\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0          j \\u2190 j - 1\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0    end while\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 51\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0      i \\u2190 i + 1\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 52\n      },\n      __self: this\n    }), \"end while\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 53\n      },\n      __self: this\n    })), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 56\n      },\n      __self: this\n    }, \"Similar with selection, with appropriate array manipulations such as shifting items in the array, the insertion sort can also be done without any further computer storage and memory requirement, which is consider another common in-place sorting algorithm. And the following animation shows the general process of insertion sort, and why this sorting algorithm can be considered as an in-place sort.\"), React.createElement(Insertion, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 59\n      },\n      __self: this\n    }), React.createElement(MergeSort, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63\n      },\n      __self: this\n    }), React.createElement(MergeSortBasic, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 64\n      },\n      __self: this\n    }));\n  }\n\n}","map":{"version":3,"sources":["/Users/wyc/Desktop/info474final/src/Components/SortingAlgorithms.js"],"names":["React","Component","SelectionSort","Insertion","MergeSortBasic","MergeSort","SortingAlgorithms","constructor","props","state","componentDidMount","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAAQC,aAAR,QAA4B,iBAA5B;AACA,SAAQC,SAAR,QAAwB,aAAxB;AACA,SAAQC,cAAR,QAA6B,kBAA7B;AACA,SAAQC,SAAR,QAAwB,aAAxB;AAEA,OAAO,MAAMC,iBAAN,SAAgCL,SAAhC,CAA0C;AAC7CM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA,SAAKC,KAAL,GAAa,EAAb;AAGH;;AAEDC,EAAAA,iBAAiB,GAAG,CAEnB;;AAEDC,EAAAA,MAAM,GAAG;AACL,WACI;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BADJ,EAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAFJ,EAGI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAHJ,EAKI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MALJ,EAQI,oBAAC,aAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MARJ,EAWI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAXJ,EAYI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uKAC4J;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAD5J,iHAE2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAF3H,sNAZJ,EAkBI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8UAlBJ,EAsBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADN,EAEC,qBAFD,OAEwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFxB,kCAG6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAH7B,qDAIqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAJrD,4DAKkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MALlE,sDAMuD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MANvD,+BAO+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAP/B,sCAQiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MARjC,eASS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MATT,CAtBJ,EAkCI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wZAlCJ,EAqCI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MArCJ,EAyCI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAzCJ,EA0CN,oBAAC,cAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA1CM,CADJ;AA8CH;;AA5D4C","sourcesContent":["import React, { Component } from 'react';\nimport {SelectionSort} from './SelectionSort'\nimport {Insertion} from './Insertion'\nimport {MergeSortBasic} from './MergeSortBasic'\nimport {MergeSort} from './MergeSort'\n\nexport class SortingAlgorithms extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <div className=\"intro-container\">\n                <h1>Sorting Algorithms</h1>\n                <h2>Selection Sort</h2>\n                <p className='intro-text'>\n                </p>\n                <p className='intro-text'>\n\n                </p>\n                <SelectionSort />\n\n\n                <h2>Insertion Sort</h2>\n                <p className='intro-text'>\n                Insertion sort using facts that are even more obvious than the fact for selection sort. For this sorting algorithm works, there are two major requirements: <br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. An array with only one or zero element is considered as a sorted array. <br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. A sorted array is still sorted when a new item is inserted at the position where its value is between its neighbors. {`(Such as 1st Neighbor < Inserted Value <2nd Neighbor)`}\n                </p>\n\n                <p className='intro-text'>\n                With those two facts, we can have an iteration that, we pick the first item of the unsorted array, and then the value is inserted into the appropriate place. And once there is no more item to be picked, we can get a sorted array. And the following pseudocode shows the basic logic to instruct computers to process insertion:\n                </p>\n\n                <code>\n                i ← 1 <br></br>\n                {'while i < length(A)'} <br></br>\n                &nbsp;&nbsp;&nbsp;     j ← i <br></br>\n                &nbsp;&nbsp;&nbsp;      while j > 0 and A[j-1] > A[j]<br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          swap A[j] and A[j-1]<br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          j ← j - 1<br></br>\n                &nbsp;&nbsp;&nbsp;    end while<br></br>\n                &nbsp;&nbsp;&nbsp;      i ← i + 1<br></br>\n                end while<br></br>\n                </code>\n\n                <p className='intro-text'>\n                Similar with selection, with appropriate array manipulations such as shifting items in the array, the insertion sort can also be done without any further computer storage and memory requirement, which is consider another common in-place sorting algorithm. And the following animation shows the general process of insertion sort, and why this sorting algorithm can be considered as an in-place sort.\n                </p>\n                <Insertion />\n\n\n                \n                <MergeSort />\n      <MergeSortBasic />\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}