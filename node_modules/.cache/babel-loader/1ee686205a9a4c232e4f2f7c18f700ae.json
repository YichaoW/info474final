{"ast":null,"code":"var _jsxFileName = \"/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/RuleOfThumb.js\";\nimport React, { Component } from 'react';\nexport class RuleOfThumb extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 18\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 19\n      },\n      __self: this\n    }, \"Rule of Thumb\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 20\n      },\n      __self: this\n    }, \"In real life, not all cases are general cases. Somtimes those analysis may not work under some special cases. One example can be, suppose the lists in your application are almost sorted, meaning there is a fix number of items that are not sorted. In this case, since the number of insertion is fixed and not dependent on the length of the array, insertion sort actually performs better since its runtime is just O(n) once the number of insertion is fixed. With those in mind, if you just want to have the algorithm with the best trade-off, considering the properties of your lists in the app can sometimes give you good advices.\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 28\n      },\n      __self: this\n    }, \"Another thing you may consider is the property of sorting algorithm: stability. Stability means, suppose two items have the same value, if the sorted list still keeps the relative order as if they are in the unsorted list. This property has lots of important applications such as sort an array with multiple categories. If you are building applications which need those features, keeping in mind about stability can help you filter some sorting algorithms that are not suitable.\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 33\n      },\n      __self: this\n    }, \"Last but not the least, try to use the trial and error technique: there are far more three sorting algorithms mentioned in this explorable explaination: quick sort, heap sort, rainbow sort, random sort... There are just so many sorting algorithms invented by computer scientists. This means, if you still not sure which sort algorithm is good for your application based in previous suggestions, just try everyone. And eventually, one of them will give you the best result.\"));\n  }\n\n}","map":{"version":3,"sources":["/Users/HowardPu/Documents/academic/info/info 474/info474final/src/Components/RuleOfThumb.js"],"names":["React","Component","RuleOfThumb","constructor","props","state","componentDidMount","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AAEA,OAAO,MAAMC,WAAN,SAA0BD,SAA1B,CAAoC;AACvCE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA,SAAKC,KAAL,GAAa,EAAb;AAGH;;AAEDC,EAAAA,iBAAiB,GAAG,CAEnB;;AAEDC,EAAAA,MAAM,GAAG;AACL,WACI;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBADJ,EAEI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8nBAFJ,EAUI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,weAVJ,EAeI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,keAfJ,CADJ;AAsBH;;AApCsC","sourcesContent":["import React, { Component } from 'react';\n\nexport class RuleOfThumb extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <div className=\"intro-container\">\n                <h1>Rule of Thumb</h1>\n                <p className='intro-text'>\n                    In real life, not all cases are general cases. Somtimes those analysis may not work under some special cases. One example can be,\n                     suppose the lists in your application are almost sorted, meaning there is a fix number of items that are not sorted. In this case, \n                      since the number of insertion is fixed and not dependent on the length of the array, insertion sort actually performs better since its runtime \n                      is just O(n) once the number of insertion is fixed. With those in mind, if you just want to have the algorithm with the best trade-off, considering \n                      the properties of your lists in the app can sometimes give you good advices.\n                </p>\n\n                <p className='intro-text'>Another thing you may consider is the property of sorting algorithm: stability. Stability means, \n                 suppose two items have the same value, if the sorted list still keeps the relative order as if they are in the unsorted list. This property has lots of \n                 important applications such as sort an array with multiple categories. If you are building applications which need those features, keeping in mind \n                 about stability can help you filter some sorting algorithms that are not suitable.</p>\n\n                <p className='intro-text'>\n                 Last but not the least, try to use the trial and error technique: there are far more three sorting algorithms mentioned in this explorable explaination:\n                 quick sort, heap sort, rainbow sort, random sort... There are just so many sorting algorithms invented by computer scientists. This means, if you still not sure\n                  which sort algorithm is good for your application based in previous suggestions, just try everyone. And eventually, one of them will give you the best result.</p>\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}