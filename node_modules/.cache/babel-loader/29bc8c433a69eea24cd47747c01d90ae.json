{"ast":null,"code":"var _jsxFileName = \"/Users/wyc/Desktop/info474final/src/Components/ComplexityAnalysis.js\";\nimport React, { Component } from 'react';\nexport class ComplexityAnalysis extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 18\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 19\n      },\n      __self: this\n    }, \"Complexity Analysis\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 20\n      },\n      __self: this\n    }, \"There are many sorting algorithms in programming world. However, there exist tradeoffs among the algorithms. In order to compare the performance of different algorithms, we should consider time complexity and space complexity. Time complexity denotes the amount of time taken by an algorithm to run based on the length of the input. Similarly, space complexity denotes the amount of space or memory taken by an algorithm to run based on the length of the input.\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 25\n      },\n      __self: this\n    }, \"Normally, we use Big O-notation to analyze algorithms. It defines an upper bound of an algorithm. The mathematic definition of Big O-notation is shown below:\"), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 29\n      },\n      __self: this\n    }, \"Insertion Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 31\n      },\n      __self: this\n    }, \"The time complexity (worst case) for insertion sort is O(n^2) since it likely will go through the whole array again for every element in the array. However, the sorting can be done within the given array so that it does not require extra memory. Thus, the space complexity is O(1).\"), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35\n      },\n      __self: this\n    }, \"Selection Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 37\n      },\n      __self: this\n    }, \"Similar to insertion sort, time complexity for selection sort is O(n^2) and space complexity is O(1).\"), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 41\n      },\n      __self: this\n    }, \"Merge Sort\"));\n  }\n\n}","map":{"version":3,"sources":["/Users/wyc/Desktop/info474final/src/Components/ComplexityAnalysis.js"],"names":["React","Component","ComplexityAnalysis","constructor","props","state","componentDidMount","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AAEA,OAAO,MAAMC,kBAAN,SAAiCD,SAAjC,CAA2C;AAC9CE,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA,SAAKC,KAAL,GAAa,EAAb;AAGH;;AAEDC,EAAAA,iBAAiB,GAAG,CAEnB;;AAEDC,EAAAA,MAAM,GAAG;AACL,WACI;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BADJ,EAEI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,udAFJ,EAOI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uKAPJ,EAWI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAXJ,EAaI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mSAbJ,EAiBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAjBJ,EAmBI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+GAnBJ,EAuBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAvBJ,CADJ;AA2BH;;AAzC6C","sourcesContent":["import React, { Component } from 'react';\n\nexport class ComplexityAnalysis extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <div className=\"intro-container\">\n                <h1>Complexity Analysis</h1>\n                <p className='intro-text'>\n                There are many sorting algorithms in programming world. However, there exist tradeoffs among the algorithms. In order to compare the performance of different algorithms, we should consider time complexity and space complexity. Time complexity denotes the amount of time taken by an algorithm to run based on the length of the input. Similarly, space complexity denotes the amount of space or memory taken by an algorithm to run based on the length of the input.\n\n                </p>\n\n                <p className='intro-text'>\n                Normally, we use Big O-notation to analyze algorithms. It defines an upper bound of an algorithm. The mathematic definition of Big O-notation is shown below:\n                </p>\n\n                <h2>Insertion Sort</h2>\n\n                <p className='intro-text'>\n                The time complexity (worst case) for insertion sort is O(n^2) since it likely will go through the whole array again for every element in the array. However, the sorting can be done within the given array so that it does not require extra memory. Thus, the space complexity is O(1).\n                </p>\n\n                <h2>Selection Sort</h2>\n\n                <p className='intro-text'>\n                Similar to insertion sort, time complexity for selection sort is O(n^2) and space complexity is O(1).\n                </p>\n\n                <h2>Merge Sort</h2>\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}