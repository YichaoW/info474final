{"ast":null,"code":"var _jsxFileName = \"/Users/wyc/Desktop/info474final/src/Components/SortingAlgorithms.js\";\nimport React, { Component } from 'react';\nimport { SelectionSort } from './SelectionSort';\nimport { Insertion } from './Insertion';\nimport { MergeSortBasic } from './MergeSortBasic';\nimport { MergeSort } from './MergeSort';\nexport class SortingAlgorithms extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"intro-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 22\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 23\n      },\n      __self: this\n    }, \"Sorting Algorithms\"), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 24\n      },\n      __self: this\n    }, \"Insertion Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 25\n      },\n      __self: this\n    }, \"Insertion sort using facts that are even more obvious than the fact for selection sort. For this sorting algorithm works, there are two major requirements: \\n\\t1: An array with only one or zero element is considered as a sorted array.\\n\\t2: A sorted array is still sorted when a new item is inserted at the position where its value is between its neighbors. (Such as 1st Neighbor < Inserted Value <2nd Neighbor)\\n                \"), React.createElement(\"code\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 31\n      },\n      __self: this\n    }, \"i \\u2190 1 \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 32\n      },\n      __self: this\n    }), 'while i < length(A)', \" \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 33\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0     j \\u2190 i \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 34\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0      while j > 0 and A[j-1] > A[j]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0          swap A[j] and A[j-1]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 36\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0          j \\u2190 j - 1\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 37\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0    end while\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 38\n      },\n      __self: this\n    }), \"\\xA0\\xA0\\xA0      i \\u2190 i + 1\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 39\n      },\n      __self: this\n    }), \"end while\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 40\n      },\n      __self: this\n    })), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 43\n      },\n      __self: this\n    }, \"Interestingly, although there are the removed values need to joint together, it does NOT need an extra array to save the sorted values. This means, the selection sorted is considered as an in-place sort, which means this sorting algorithm may not need other computer memory usage other than just the given place for the initial array. And the following animation shows the general process of selection sort, and why this sorting algorithm can be considered as an in-place sort.\"), React.createElement(Insertion, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46\n      },\n      __self: this\n    }), React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 49\n      },\n      __self: this\n    }, \"Selection Sort\"), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50\n      },\n      __self: this\n    }), React.createElement(\"p\", {\n      className: \"intro-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 52\n      },\n      __self: this\n    }), React.createElement(SelectionSort, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 55\n      },\n      __self: this\n    }), React.createElement(MergeSort, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 57\n      },\n      __self: this\n    }), React.createElement(MergeSortBasic, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }));\n  }\n\n}","map":{"version":3,"sources":["/Users/wyc/Desktop/info474final/src/Components/SortingAlgorithms.js"],"names":["React","Component","SelectionSort","Insertion","MergeSortBasic","MergeSort","SortingAlgorithms","constructor","props","state","componentDidMount","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAAQC,aAAR,QAA4B,iBAA5B;AACA,SAAQC,SAAR,QAAwB,aAAxB;AACA,SAAQC,cAAR,QAA6B,kBAA7B;AACA,SAAQC,SAAR,QAAwB,aAAxB;AAEA,OAAO,MAAMC,iBAAN,SAAgCL,SAAhC,CAA0C;AAC7CM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA,SAAKC,KAAL,GAAa,EAAb;AAGH;;AAEDC,EAAAA,iBAAiB,GAAG,CAEnB;;AAEDC,EAAAA,MAAM,GAAG;AACL,WACI;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BADJ,EAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAFJ,EAGI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ubAHJ,EASI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADN,EAEC,qBAFD,OAEwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFxB,kCAG6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAH7B,qDAIqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAJrD,4DAKkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MALlE,sDAMuD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MANvD,+BAO+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAP/B,sCAQiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MARjC,eASS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MATT,CATJ,EAqBI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ueArBJ,EAwBI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAxBJ,EA2BI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBA3BJ,EA4BI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA5BJ,EA8BI;AAAG,MAAA,SAAS,EAAC,YAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA9BJ,EAiCI,oBAAC,aAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAjCJ,EAmCI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAnCJ,EAoCN,oBAAC,cAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MApCM,CADJ;AAwCH;;AAtD4C","sourcesContent":["import React, { Component } from 'react';\nimport {SelectionSort} from './SelectionSort'\nimport {Insertion} from './Insertion'\nimport {MergeSortBasic} from './MergeSortBasic'\nimport {MergeSort} from './MergeSort'\n\nexport class SortingAlgorithms extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <div className=\"intro-container\">\n                <h1>Sorting Algorithms</h1>\n                <h2>Insertion Sort</h2>\n                <p className='intro-text'>\n                {`Insertion sort using facts that are even more obvious than the fact for selection sort. For this sorting algorithm works, there are two major requirements: \n\t1: An array with only one or zero element is considered as a sorted array.\n\t2: A sorted array is still sorted when a new item is inserted at the position where its value is between its neighbors. (Such as 1st Neighbor < Inserted Value <2nd Neighbor)\n                `}</p>\n\n                <code>\n                i ← 1 <br></br>\n                {'while i < length(A)'} <br></br>\n                &nbsp;&nbsp;&nbsp;     j ← i <br></br>\n                &nbsp;&nbsp;&nbsp;      while j > 0 and A[j-1] > A[j]<br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          swap A[j] and A[j-1]<br></br>\n                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          j ← j - 1<br></br>\n                &nbsp;&nbsp;&nbsp;    end while<br></br>\n                &nbsp;&nbsp;&nbsp;      i ← i + 1<br></br>\n                end while<br></br>\n                </code>\n\n                <p className='intro-text'>\n                Interestingly, although there are the removed values need to joint together, it does NOT need an extra array to save the sorted values. This means, the selection sorted is considered as an in-place sort, which means this sorting algorithm may not need other computer memory usage other than just the given place for the initial array. And the following animation shows the general process of selection sort, and why this sorting algorithm can be considered as an in-place sort.\n                </p>\n                <Insertion />\n\n\n                <h2>Selection Sort</h2>\n                <p className='intro-text'>\n                </p>\n                <p className='intro-text'>\n\n                </p>\n                <SelectionSort />\n\n                <MergeSort />\n      <MergeSortBasic />\n            </div>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}